{
  "docs": {
    "headings": [
      {
        "name": "Models",
        "description": "",
        "subheadings": [
          {
            "name": "Classes",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "SymbolicTensor",
                "documentation": "`SymbolicTensor` is a symbolic `Tensor` without any concrete value.\nIt can be used during the building phase of models that involve no actual\nexecution of the computation defined in the model.",
                "fileName": "#66",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/types.ts#L66-L104",
                "methods": [],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Model",
                "documentation": "The `Model` class adds training & evaluation routines to a `Container`.\n\nA `Model` is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a `Model, use `model`.\n\nTo create a `Model`, specify its input(s) and output(s). Inputs are\n`SymbolicTensor`s provided by `Input` layers. Outputs are `SymbolicTensor`s\nprovided by other layers that perform mathematical and neural-network\noperations.\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with of 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\n\nSee also:\n   `Sequential`, `modelFromJSON`, `loadModel`.",
                "fileName": "#612",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L612-L1576",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "compile",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelCompileConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "",
                    "fileName": "#643",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L643-L835",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluate",
                    "paramStr": "(x, y, batchSize?, verbose?, sampleWeight?, steps?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "Tensor of test data, or list of Tensors if the model has\nmultiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "Tensor of target data, or list of Tensors if the model has\nmultiple outputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to true.",
                        "type": "ModelLoggingVerbosity",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "sampleWeight",
                        "documentation": "Tensor of weights to weight the contribution\nof different samples to the loss and metrics.",
                        "type": "Tensor",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "steps",
                        "documentation": "Integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. When `steps` is not\nprovided, will perform evaluation on all exapmles in `x` and `y` and\ndeclare evaluation finished.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Scalar|Scalar[]",
                    "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.",
                    "fileName": "#885",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L885-L903",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predict",
                    "paramStr": "(x, batchSize?, verbose?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "The input data, as an Tensor (or `Array` of `Tensor`s if the\nmodel has multiple outputs).",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "Integer. If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to false.",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor\n      |Tensor[]",
                    "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.\n\nPorting Note: the \"step\" mode of predict() is currently not supported.\nThis is because the TensorFow.js core backend is imperative only.",
                    "fileName": "#1022",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1022-L1031",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predictOnBatch",
                    "paramStr": "(x)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": ": Input samples, as an Tensor",
                        "type": "Tensor",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor|Tensor[]",
                    "documentation": "Returns predictions for a single batch of samples.",
                    "fileName": "#1039",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1039-L1045",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fit",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelFitConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise",
                    "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).",
                    "fileName": "#1383",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/engine/training.ts#L1383-L1575",
                    "isFunction": true
                  }
                ],
                "isClass": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Classes"
                },
                "symbolName": "Sequential",
                "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n`sequential` is a factory function that creates an instance of\n`Sequential`.\n\n# Arguments",
                "fileName": "#212",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L212-L540",
                "methods": [
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "add",
                    "paramStr": "(layer)",
                    "parameters": [
                      {
                        "name": "layer",
                        "documentation": "Layer instance.",
                        "type": "Layer",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "void",
                    "documentation": "Adds a layer instance on top of the layer stack.",
                    "fileName": "#244",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L244-L319",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "evaluate",
                    "paramStr": "(x, y, batchSize?, verbose?, sampleWeight?, steps?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "Tensor of test data, or list of Tensors if the model has\nmultiple inputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "y",
                        "documentation": "Tensor of target data, or list of Tensors if the model has\nmultiple outputs.",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to true.",
                        "type": "ModelLoggingVerbosity",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "sampleWeight",
                        "documentation": "Tensor of weights to weight the contribution\nof different samples to the loss and metrics.",
                        "type": "Tensor",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "steps",
                        "documentation": "Optional integer: total number of steps (batches of samples)\nbefore declaring the evaluation round finished. Ignored with the default\nvalue of `undefined`.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Scalar|Scalar[]",
                    "documentation": "Returns the loss value & metrics values for the model in test mode.\n\nLoss and metrics are specified during `compile()`, which needs to happen\nbefore calls to `evaluate()`.\n\nComputation is done in batches.",
                    "fileName": "#437",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L437-L447",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "predict",
                    "paramStr": "(x, batchSize?, verbose?)",
                    "parameters": [
                      {
                        "name": "x",
                        "documentation": "The input data, as an Tensor (or list of Tensors if the model\nhas multiple outputs).",
                        "type": "Tensor|Tensor[]",
                        "optional": false,
                        "isConfigParam": false
                      },
                      {
                        "name": "batchSize",
                        "documentation": "Integer. If unspecified, it will default to 32.",
                        "type": "number",
                        "optional": true,
                        "isConfigParam": false
                      },
                      {
                        "name": "verbose",
                        "documentation": "Verbosity mode. Defaults to false.",
                        "type": "boolean",
                        "optional": true,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Tensor\n      |Tensor[]",
                    "documentation": "Generates output predictions for the input samples.\n\nComputation is done in batches.",
                    "fileName": "#460",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L460-L467",
                    "isFunction": true
                  },
                  {
                    "docInfo": {
                      "heading": "Models",
                      "subheading": "Classes"
                    },
                    "symbolName": "fit",
                    "paramStr": "(config)",
                    "parameters": [
                      {
                        "name": "config",
                        "documentation": "",
                        "type": "ModelFitConfig",
                        "optional": false,
                        "isConfigParam": false
                      }
                    ],
                    "returnType": "Promise",
                    "documentation": "Trains the model for a fixed number of epochs (iterations on a dataset).",
                    "fileName": "#507",
                    "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/models.ts#L507-L515",
                    "isFunction": true
                  }
                ],
                "isClass": true
              }
            ]
          },
          {
            "name": "Creation",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation",
                  "useDocsFrom": "Model",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "model",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Model",
                "documentation": "The `Model` class adds training & evaluation routines to a `Container`.\n\nA `Model` is the basic unit of training, inference and evaluation in\nTensorFlow.js. To create a `Model, use `model`.\n\nTo create a `Model`, specify its input(s) and output(s). Inputs are\n`SymbolicTensor`s provided by `Input` layers. Outputs are `SymbolicTensor`s\nprovided by other layers that perform mathematical and neural-network\noperations.\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with of 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\n\nSee also:\n   `Sequential`, `modelFromJSON`, `loadModel`.",
                "fileName": "#41",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L41-L49",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Creation",
                  "useDocsFrom": "Sequential",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "sequential",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Sequential",
                "documentation": "A model with a stack of layers, feeding linearly from one to the next.\n\n`sequential` is a factory function that creates an instance of\n`Sequential`.\n\n# Arguments",
                "fileName": "#51",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L51-L59",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Loading",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Loading",
                  "useDocsFrom": "loadModelInternal"
                },
                "symbolName": "loadModel",
                "paramStr": "(modelConfigPath)",
                "parameters": [
                  {
                    "name": "modelConfigPath",
                    "documentation": "A path to the `ModelAndWeightsConfig` JSON describing\nthe model in the canonical TensorFlow.js format.\n\nThis provides the most convenient way to load a TensorFlow.js saved model.\n\nThe content of `model.json` is assumed to be a JSON object with the\nfollowing fields and values:\n- 'modelTopology': A JSON object that can be\n- a model architecture JSON consistent with the format of the return\nvalue of `keras.Model.to_json()`, or\n- a full model JSON in the format of `keras.models.save_model()`.\n- 'weightsManifest': A TensorFlow.js weights manifest.\nSee the Python converter function `save_model()` for more details.\n\nIt is also assumed that model weights can be accessed from relative paths\ndescribed by the `paths` fields in weights manifest.",
                    "type": "string",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "Promise",
                "documentation": "Load a model, including its topology and optionally weights.",
                "fileName": "#61",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L61-L68",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Inputs",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Inputs",
                  "useDocsFrom": "Input",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "input",
                "paramStr": "(config)",
                "parameters": [
                  {
                    "name": "config",
                    "documentation": "",
                    "type": "InputConfig",
                    "optional": false,
                    "isConfigParam": false
                  }
                ],
                "returnType": "SymbolicTensor",
                "documentation": "`Input()` is used to instantiate a SymbolicTensor, and represents\nthe input to a model.\n\nExample:\n\n     // this is a logistic regression in TF.js Layers:\n     x = new Input(shape=[32]);\n     y = new Dense(16, activation='softmax').apply(x);\n     model = new Model(x, y);",
                "fileName": "#70",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L70-L78",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Models",
                  "subheading": "Inputs",
                  "useDocsFrom": "InputLayer",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "inputLayer",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "InputLayer",
                "documentation": "Layer to be used as an entry point into a graph.",
                "fileName": "#80",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L80-L88",
                "isFunction": true
              }
            ]
          }
        ]
      },
      {
        "name": "Layers",
        "description": "",
        "subheadings": [
          {
            "name": "Convolutional",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "Conv1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "conv1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Conv1D",
                "documentation": "1D convolution layer (e.g., temporal convolution).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input over a single spatial (or temporal) dimension\nto produce a tensor of outputs.\nIf `use_bias` is True, a bias vector is created and added to the outputs.\nFinally, if `activation` is not `null` or `undefined`,\nit is applied to the outputs as well.\nWhen using this layer as the first layer in a model,\nprovide an `inputShape` argument Array or `null`, e.g.\n`[10, 128]` for sequences of 10 vectors of 128-dimensional vectors,\nor `[null, 128]` for variable-length sequences of 128-dimensional vectors.",
                "fileName": "#98",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L98-L107",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "Conv2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "conv2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Conv2D",
                "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs.\n\nIf `useBias` is True, a bias vector is created and added to the outputs.\n\nIf `activation` is not `None`, it is applied to the outputs as well.\n\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat=DataFormat.CHANNEL_LAST`.",
                "fileName": "#109",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L109-L118",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Convolutional",
                  "namespace": "layers",
                  "useDocsFrom": "DepthwiseConv2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "depthwiseConv2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "DepthwiseConv2D",
                "documentation": "Depthwise separable 2D convolution.\n\nDepthwise Separable convolutions consists in performing just the first step\nin a depthwise spatial convolution (which acts on each input channel\nseparately). The `depthMultplier` argument controls how many output channels\nare generated per input channel in the depthwise step.",
                "fileName": "#122",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L122-L131",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Core",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Activation",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "activation",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Activation",
                "documentation": "Applies an activation function to an output.",
                "fileName": "#134",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L134-L143",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Dense",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "dense",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Dense",
                "documentation": "Just your regular densely-connected NN layer.\n   `Dense` implements the operation:\n   `output = activation(dot(input, kernel) + bias)`\n   where `activation` is the element-wise activation function\n   passed as the `activation` argument, `kernel` is a weights matrix\n   created by the layer, and `bias` is a bias vector created by the layer\n   (only applicable if `useBias` is `true`).\n   Note: if the input to the layer has a rank greater than 2, then\n   it is flattened prior to the initial dot product with `kernel`.\n\nInput shape\n   nD tensor with shape: `(batchSize, ..., inputDim)`.\n   The most common situation would be\n   a 2D input with shape `(batchSize, inputDim)`.\nOutput shape\n   nD tensor with shape: `(batchSize, ..., units)`.\n   For instance, for a 2D input with shape `(batchSize, inputDim)`,\n   the output would have shape `(batchSize, units)`.",
                "fileName": "#145",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L145-L154",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Dropout",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "dropout",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Dropout",
                "documentation": "Applies Dropout to the input.\n\nDropout consists in randomly setting\na fraction `rate` of input units to 0 at each update during training time,\nwhich helps prevent overfitting.\n\nReferences\n- [Dropout: A Simple Way to Prevent Neural Networks from\nOverfitting](http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf)",
                "fileName": "#156",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L156-L165",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Flatten",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "flatten",
                "namespace": "layers",
                "paramStr": "(config?)",
                "parameters": [],
                "returnType": "Flatten",
                "documentation": "Flattens the input. Does not affect the batch size.\n\nA `Flatten` layer flattens each batch sample in its inputs to 1D (hence the\noutput is 2D total).\n\nFor example:\n\n```js\nconst input = tf.input({shape: [4, 3]});\nconst flattenLayer = tf.layers.flatten();\n// Inspect the inferred output shape of the flatten layer, which\n// equals `[null, 12]`. The 2nd dimension is 4 * 3, i.e., the result of the\n// flattening. (The 1st dimension is the undermined batch size.)\nconsole.log(flattenLayer.apply(input).shape);\n```",
                "fileName": "#167",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L167-L176",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "RepeatVector",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "repeatVector",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "RepeatVector",
                "documentation": "Repeat the input n times.",
                "fileName": "#178",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L178-L187",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Core",
                  "namespace": "layers",
                  "useDocsFrom": "Embedding",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "embedding",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Embedding",
                "documentation": "Turns positive integers (indexes) into dense vectors of fixed size.\neg. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]\n\n   # Input shape\n       2D tensor with shape: `[batchSize, sequenceLength]`.\n\n   # Output shape\n       3D tensor with shape: `[batchSize, sequenceLength, outputDim]`.",
                "fileName": "#189",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L189-L198",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Merge",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Add",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "add",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Add",
                "documentation": "Layer that adds a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#202",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L202-L211",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Average",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "average",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Average",
                "documentation": "Layer that averages a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape, and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#213",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L213-L222",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Concatenate",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "concatenate",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Concatenate",
                "documentation": "Layer that concatenates a list of inputs.\n\nIt takes a list of tensors, all of the same shape except for the\nconcatenation axis, and returns a single tensor, the concatenation\nof all inputs.",
                "fileName": "#224",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L224-L233",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Maximum",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maximum",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Maximum",
                "documentation": "Layer that computes the maximum (element-wise) a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#235",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L235-L244",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Minimum",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "minimum",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Minimum",
                "documentation": "Layer that computes the minimum (element-wise) a list of inputs.\n\nIt takes as input a list of tensors, all of the same shape and returns a\nsingle tensor (also of the same shape).",
                "fileName": "#246",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L246-L255",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Merge",
                  "namespace": "layers",
                  "useDocsFrom": "Multiply",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "multiply",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Multiply",
                "documentation": "Layer that multiplies (element-wise) an Array of inputs.\n\nIt takes as input an Array of tensors, all of the same\nshape, and returns a single tensor (also of the same shape).",
                "fileName": "#257",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L257-L266",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Normalization",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Normalization",
                  "namespace": "layers",
                  "useDocsFrom": "BatchNormalization",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "batchNormalization",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "BatchNormalization",
                "documentation": "Batch normalization layer (Ioffe and Szegedy, 2014).\n\nNormalize the activations of the previous layer at each batch,\ni.e. applies a transformation that maintains the mean activation\nclose to 0 and the activation standard deviation close to 1.\n\nInput shape:\n   Arbitrary. Use the keyword argument `inputShape` (Array of integers, does\n   not include the sample axis) when calling the constructor of this class,\n   if this layer is used as a first layer in a model.\n\nOutput shape:\n   Same shape as input.\n\nReferences:\n   - [Batch Normalization: Accelerating Deep Network Training by Reducing\nInternal Covariate Shift](https://arxiv.org/abs/1502.03167)",
                "fileName": "#270",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L270-L280",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Pooling",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "AvgPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "avgPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "AvgPooling1D",
                "documentation": "Average pooling operation for spatial data.\n   Input shape:  `[batchSize, inLength, channels]`\n   Output shape: `[batchSize, pooledLength, channels]`",
                "fileName": "#283",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L283-L292",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "AvgPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "avgPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "AvgPooling2D",
                "documentation": "Average pooling operation for spatial data.\n   Input shape\n      - If `dataFormat === CHANNEL_LAST`:\n          4D tensor with shape:\n          `[batchSize, rows, cols, channels]`\n      - If `dataFormat === CHANNEL_FIRST`:\n          4D tensor with shape:\n          `[batchSize, channels, rows, cols]`\n   Output shape\n      - If `dataFormat === CHANNEL_LAST`:\n          4D tensor with shape:\n          `[batchSize, pooleRows, pooledCols, channels]`\n      - If `dataFormat === CHANNEL_FIRST`:\n          4D tensor with shape:\n          `[batchSize, channels, pooleRows, pooledCols]`",
                "fileName": "#294",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L294-L303",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalAveragePooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalAveragePooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GlobalAveragePooling1D",
                "documentation": "Global average pooling operation for temporal data.\nInput Shape:\n   3D tensor with shape: `[batchSize, steps, features]`.\nOutput Shape:\n   2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#305",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L305-L314",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalAveragePooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalAveragePooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GlobalAveragePooling2D",
                "documentation": "Global average pooling operation for spatial data.\n\nInput shape:\n   If `dataFormat` is `CHANNEL_LAST`:\n     4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   If `dataFormat` is `CHANNEL_FIRST`:\n     4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#316",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L316-L326",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalMaxPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalMaxPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GlobalMaxPooling1D",
                "documentation": "Global max pooling operation for temporal data.\nInput Shape:\n   3D tensor with shape: `[batchSize, steps, features]`.\nOutput Shape:\n   2D tensor with shape: `[batchSize, features]`.",
                "fileName": "#328",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L328-L337",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "GlobalMaxPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "globalMaxPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GlobalMaxPooling2D",
                "documentation": "Global max pooling operation for spatial data.\n\nInput shape:\n   If `dataFormat` is `CHANNEL_LAST`:\n     4D tensor with shape: `[batchSize, rows, cols, channels]`.\n   If `dataFormat` is `CHANNEL_FIRST`:\n     4D tensor with shape: `[batchSize, channels, rows, cols]`.\n\nOutput shape:\n   2D tensor with shape: `[batchSize, channels]`.",
                "fileName": "#339",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L339-L349",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "MaxPooling1D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maxPooling1d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "MaxPooling1D",
                "documentation": "Max pooling operation for temporal data.\n   Input shape:  `[batchSize, inLength, channels]`\n   Output shape: `[batchSize, pooledLength, channels]`",
                "fileName": "#351",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L351-L360",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Pooling",
                  "namespace": "layers",
                  "useDocsFrom": "MaxPooling2D",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "maxPooling2d",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "MaxPooling2D",
                "documentation": "Max pooling operation for spatial data.\n   Input shape\n      - If `dataFormat === CHANNEL_LAST`:\n          4D tensor with shape:\n          `[batchSize, rows, cols, channels]`\n      - If `dataFormat === CHANNEL_FIRST`:\n         4D tensor with shape:\n          `[batchSize, channels, rows, cols]`\n   Output shape\n      - If `dataFormat=CHANNEL_LAST`:\n          4D tensor with shape:\n          `[batchSize, pooleRows, pooledCols, channels]`\n      - If `dataFormat=CHANNEL_FIRST`:\n          4D tensor with shape:\n          `[batchSize, channels, pooleRows, pooledCols]`",
                "fileName": "#362",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L362-L371",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Recurrent",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "GRU",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "gru",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GRU",
                "documentation": "Gated Recurrent Unit - Cho et al. 2014.",
                "fileName": "#375",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L375-L384",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "GRUCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "gruCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "GRUCell",
                "documentation": "Cell class for the GRU layer.",
                "fileName": "#386",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L386-L395",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "LSTM",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "lstm",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "LSTM",
                "documentation": "Long-Short Term Memory layer - Hochreiter 1997.",
                "fileName": "#397",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L397-L406",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "LSTMCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "lstmCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "LSTMCell",
                "documentation": "Cell class for the LSTM layer.",
                "fileName": "#408",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L408-L417",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "SimpleRNN",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "simpleRNN",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "SimpleRNN",
                "documentation": "Fully-connected RNN where the output is to be fed back to input.",
                "fileName": "#419",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L419-L428",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Recurrent",
                  "namespace": "layers",
                  "useDocsFrom": "SimpleRNNCell",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "simpleRNNCell",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "SimpleRNNCell",
                "documentation": "",
                "fileName": "#430",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L430-L439",
                "isFunction": true
              }
            ]
          },
          {
            "name": "Wrapper",
            "symbols": [
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers",
                  "useDocsFrom": "Bidirectional",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "bidirectional",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "Bidirectional",
                "documentation": "",
                "fileName": "#443",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L443-L452",
                "isFunction": true
              },
              {
                "docInfo": {
                  "heading": "Layers",
                  "subheading": "Wrapper",
                  "namespace": "layers",
                  "useDocsFrom": "TimeDistributed",
                  "configParamIndices": [
                    0
                  ]
                },
                "symbolName": "timeDistributed",
                "namespace": "layers",
                "paramStr": "(config)",
                "parameters": [],
                "returnType": "TimeDistributed",
                "documentation": "This wrapper applies a layer to every temporal slice of an input.\n\nThe input should be at least 3D,  and the dimension of the index `1` will be\nconsidered to be the temporal dimension.\n\nConsider a batch of 32 samples, where each sample is a sequence of 10 vectors\nof 16 dimensions. The batch input shape of the layer is then `[32,  10,\n16]`, and the `inputShape`, not including the sample dimension, is\n`[10, 16]`.\n\nYou can then use `TimeDistributed` to apply a `Dense` layer to each of the 10\ntimesteps, independently:\n\n```typescript\nconst model = new Sequential();\nmodel.add(new TimeDistributed({\n   layer: new Dense({units: 8}),\n   inputShape: [10, 16],\n});\n// Now model.outputShape = [null, 10, 8].\n```\n\nThe output will then have shape `[32, 10, 8]`.\n\nIn subsequent layers, there is no need for `inputShape`:\n```typescript\nmodel.add(new TimeDistributed({layer: new Dense(32)});\n// Now model.outputShape = [null, 10, 32].\n```\n\nThe output will then have shape `[32, 10, 32]`.\n\n`TimeDistributed` can be used with arbitrary layers, not just `Dense`, for\ninstance a `Conv2D` layer.\n\n```typescript\nconst model = new Sequential();\nmodel.add(new TimeDistributed({\n   layer: new Conv2D({filter: 64, kernelSize: [3, 3]}),\n   inputShape: [10, 299, 299, 3]\n});\n```",
                "fileName": "#454",
                "githubUrl": "https://github.com/tensorflow/tfjs-layers/blob/master/src/exports.ts#L454-L463",
                "isFunction": true
              }
            ]
          }
        ]
      }
    ]
  },
  "docLinkAliases": {}
}