{
  "headings": [
    {
      "name": "Tensors",
      "description": "",
      "subheadings": [
        {
          "name": "Creation",
          "description": "<p>Tensors are the core datastructure of deeplearn.js.\n             They are a generalization of vectors and matrices to potentially\n             higher dimensions.\n             </p>\n             <p>We have utility functions for common cases like Scalar, 1D,\n             2D, 3D and 4D tensors, as well a number of functions to initialize\n             tensors in ways useful for machine learning.</p>",
          "pin": [
            "tensor",
            "scalar",
            "tensor1d",
            "tensor2d",
            "tensor3d",
            "tensor4d"
          ],
          "symbols": []
        },
        {
          "name": "Classes",
          "description": "<p>\n          This section shows the main Tensor related classes in deeplearn.js and\n          the methods we expose on them.\n          </p>",
          "pin": [
            "Tensor",
            "Variable",
            "TensorBuffer"
          ],
          "symbols": []
        },
        {
          "name": "Transformations",
          "description": "<p>This section describes some common Tensor\n              transformations for reshaping and type-casting.</p>",
          "symbols": []
        },
        {
          "name": "Slicing and Joining",
          "description": "<p>deeplearn.js provides several operations\n              to slice or extract parts of a tensor, or join multiple\n              tensors together.",
          "symbols": []
        }
      ]
    },
    {
      "name": "Operations",
      "description": "",
      "subheadings": [
        {
          "name": "Arithmetic",
          "description": "<p>To perform mathematical computation on Tensors, we use\n              operations. Tensors are immutable, so all operations always return\n              new Tensors and never modify input Tensors.</p>",
          "pin": [
            "add",
            "sub",
            "mul",
            "div"
          ],
          "symbols": []
        },
        {
          "name": "Basic math",
          "symbols": []
        },
        {
          "name": "Matrices",
          "symbols": []
        },
        {
          "name": "Convolution",
          "symbols": []
        },
        {
          "name": "Reduction",
          "symbols": []
        },
        {
          "name": "Normalization",
          "symbols": []
        },
        {
          "name": "Images",
          "symbols": []
        },
        {
          "name": "RNN",
          "symbols": []
        },
        {
          "name": "Logical",
          "symbols": []
        }
      ]
    },
    {
      "name": "Training",
      "description": "<p>We also provide an API to do perform training, and\n      compute gradients. We compute gradients eagerly, users provide a function\n      that is a combination of operations and we automatically differentiate\n      that function's output with respect to its inputs.\n\n      <p>For those familiar with TensorFlow, the API we expose exactly mirrors\n      the TensorFlow Eager API.\n      </p>",
      "subheadings": [
        {
          "name": "Gradients",
          "pin": [
            "grad",
            "grads",
            "valAndGrad",
            "valAndGrads",
            "customGrad"
          ],
          "symbols": []
        },
        {
          "name": "Optimizers",
          "pin": [
            "sgd",
            "momentum",
            "adagrad",
            "adadelta"
          ],
          "symbols": []
        },
        {
          "name": "Losses",
          "symbols": []
        },
        {
          "name": "Classes",
          "symbols": []
        }
      ]
    },
    {
      "name": "Performance",
      "description": "<p>",
      "subheadings": [
        {
          "name": "Memory",
          "pin": [
            "tidy"
          ],
          "symbols": []
        },
        {
          "name": "Timing",
          "pin": [
            "time"
          ],
          "symbols": []
        }
      ]
    },
    {
      "name": "Environment",
      "description": "<p>deeplearn.js can run mathematical operations on\n          different backends. Currently, we support WebGL and JavaScript\n          CPU. By default, we choose the 'best' backend available, but\n          allow users to customize their backend.",
      "subheadings": [
        {
          "name": "",
          "pin": [
            "setBackend"
          ],
          "symbols": []
        }
      ]
    },
    {
      "name": "Models",
      "description": "",
      "subheadings": [
        {
          "name": "",
          "symbols": [
            {
              "docInfo": {
                "heading": "Models",
                "useDocsFrom": "Model",
                "subheading": ""
              },
              "symbolName": "model",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "ContainerConfig",
                  "optional": false
                }
              ],
              "returnType": "Model",
              "documentation": "The `Model` class adds training & evaluation routines to a `Container`.\n\nA `Model` is the basic unit of training, inference and evaluation in\nTensorFlow.js. `tf.model` is a factory function that creates an instance\nof `Model`.\n\nTo create a `Model`, specify its input(s) and output(s). Inputs are\n`SymbolicTensor`s provided by `Input` layers. Outputs are `SymbolicTensor`s\nprovided by other layers that perform mathematical and neural-network\noperations.\n\nFor example, the following code snippet defines a model consisting of\ntwo `dense` layers, with of 10 and 4 units, respectively.\n\n```js\n// Define input, which has a size of 5 (not including batch dimension).\nconst input = tf.input({shape: [5]});\n\n// First dense layer uses relu activation.\nconst denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'});\n// Second dense layer uses softmax activation.\nconst denseLayer2 = tf.layers.dense({units: 2, activation: 'softmax'});\n\n// Obtain the output symbolic tensor by applying the layers on the input.\nconst output = denseLayer2.apply(denseLayer1.apply(input));\n\n// Create the model based on the inputs.\nconst model = tf.model({inputs: input, outputs: output});\n\n// The model can be used for training, evaluation and prediction.\n// For example, the following line runs prediction with the model on\n// some fake data.\nmodel.predict(tf.ones([2, 5])).print();\n```\n\nSee also:\n   `Sequential`, `modelFromJSON`, `loadModel`.",
              "fileName": "#41",
              "githubUrl": "https://github.com/tensorflow/tfjs-layersblob/master/src/exports.ts#L41-L44",
              "isFunction": true,
              "displayName": "dl.model",
              "urlHash": "dl.model"
            }
          ]
        }
      ]
    },
    {
      "name": "Layers",
      "description": "",
      "subheadings": [
        {
          "name": "Convolutional",
          "symbols": [
            {
              "docInfo": {
                "heading": "Layers",
                "subheading": "Convolutional",
                "namespace": "layers",
                "useDocsFrom": "Conv2D",
                "configParamIndices": [
                  0
                ]
              },
              "symbolName": "conv2d",
              "namespace": "layers",
              "paramStr": "(config)",
              "parameters": [
                {
                  "name": "config",
                  "documentation": "",
                  "type": "ConvLayerConfig",
                  "optional": false
                },
                {
                  "name": "kernelSize",
                  "documentation": "kernelSize: An integer or an array of integers, specifying the\n   dimensions of the convolution window.",
                  "type": "number|number[]",
                  "optional": false
                },
                {
                  "name": "filters",
                  "documentation": "filters: Integer, the dimensionality of the output space\n   (i.e. the number output of filters in the convolution).",
                  "type": "number",
                  "optional": true
                },
                {
                  "name": "strides",
                  "documentation": "strides: An integer or tuple/list of n integers,\n   specifying the strides of the convolution.\n   Specifying any stride value != 1 is incompatible with specifying\n   any `dilationRate` value != 1.",
                  "type": "number|number[]",
                  "optional": true
                },
                {
                  "name": "padding",
                  "documentation": "padding: Padding mode, e.g., VALID.",
                  "type": "PaddingMode",
                  "optional": true
                },
                {
                  "name": "dataFormat",
                  "documentation": "dataFormat: Format of the data, e.g., CHANNEL_LAST.\n   The ordering of the dimensions in the inputs.\n   `channels_last` corresponds to inputs with shape\n   `(batch, ..., channels)` while `channels_first` corresponds to\n   inputs with shape `(batch, channels, ...)`.\n   Defaults to \"channels_last\".",
                  "type": "DataFormat",
                  "optional": true
                },
                {
                  "name": "dilationRate",
                  "documentation": "dilation_rate: An integer or array of integers, specifying\n   the dilation rate to use for dilated convolution.\n   Currently, specifying any `dilationRate` value != 1 is\n   incompatible with specifying any `strides` value != 1.",
                  "type": "number|number[]",
                  "optional": true
                },
                {
                  "name": "activation",
                  "documentation": "activation: Activation function to use\n   If you don't specify anything, no activation is applied\n   (ie. \"linear\" activation: `a(x) = x`).",
                  "type": "string",
                  "optional": true
                },
                {
                  "name": "useBias",
                  "documentation": "useBias: Boolean, whether the layer uses a bias vector.",
                  "type": "boolean",
                  "optional": true
                },
                {
                  "name": "kernelInitializer",
                  "documentation": "kernelInitializer: Initializer for the `kernel` weights matrix",
                  "type": "string|initializers.Initializer",
                  "optional": true
                },
                {
                  "name": "biasInitializer",
                  "documentation": "biasInitializer: Initializer for the bias vector",
                  "type": "string|initializers.Initializer",
                  "optional": true
                },
                {
                  "name": "kernelConstraint",
                  "documentation": "kernelConstraint: Constraint for the kernel weights",
                  "type": "string|constraints.Constraint",
                  "optional": true
                },
                {
                  "name": "biasConstraint",
                  "documentation": "biasConstraint: Constraint for the bias vector",
                  "type": "string|constraints.Constraint",
                  "optional": true
                },
                {
                  "name": "kernelRegularizer",
                  "documentation": "kernelRegularizer:  Regularizer function applied to the `kernel` weights\nmatrix",
                  "type": "string|regularizers.Regularizer",
                  "optional": true
                },
                {
                  "name": "biasRegularizer",
                  "documentation": "biasRegularizer:  Regularizer function applied to the bias vector",
                  "type": "string|regularizers.Regularizer",
                  "optional": true
                },
                {
                  "name": "activityRegularizer",
                  "documentation": "activityRegularizer:  Regularizer function applied to the activation",
                  "type": "string|regularizers.Regularizer",
                  "optional": true
                }
              ],
              "returnType": "Conv2D",
              "documentation": "2D convolution layer (e.g. spatial convolution over images).\n\nThis layer creates a convolution kernel that is convolved\nwith the layer input to produce a tensor of outputs. If `useBias` is True,\na bias vector is created and added to the outputs. Finally, if\n`activation` is not `None`, it is applied to the outputs as well.\nWhen using this layer as the first layer in a model,\nprovide the keyword argument `inputShape`\n(Array of integers, does not include the sample axis),\ne.g. `inputShape=[128, 128, 3]` for 128x128 RGB pictures\nin `dataFormat=DataFormat.CHANNEL_LAST`.",
              "fileName": "#74",
              "githubUrl": "https://github.com/tensorflow/tfjs-layersblob/master/src/exports.ts#L74-L83",
              "isFunction": true,
              "displayName": "dl.layers.conv2d",
              "urlHash": "dl.layers.conv2d"
            }
          ]
        }
      ]
    }
  ],
  "bundleJsPath": "/usr/local/google/home/nsthorat/deeplearnjs-clients/website/tfjs-website/libs/tfjs-layers/dist/deeplearn.js"
}